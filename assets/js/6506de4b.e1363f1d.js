"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2987],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7587:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var i=n(7462),a=n(3366),o=(n(7294),n(3905)),r=["components"],l={id:"dev-guide-ios-sdk",title:"iOS SDK"},s=void 0,p={unversionedId:"dev-guide/dev-guide-ios-sdk",id:"dev-guide/dev-guide-ios-sdk",title:"iOS SDK",description:"The Jitsi Meet iOS SDK provides the same user experience as the Jitsi Meet app,",source:"@site/docs/dev-guide/ios-sdk.md",sourceDirName:"dev-guide",slug:"/dev-guide/dev-guide-ios-sdk",permalink:"/handbook/docs/dev-guide/dev-guide-ios-sdk",draft:!1,editUrl:"https://github.com/jitsi/handbook/edit/master/docs/dev-guide/ios-sdk.md",tags:[],version:"current",lastUpdatedAt:1697612987,formattedLastUpdatedAt:"Oct 18, 2023",frontMatter:{id:"dev-guide-ios-sdk",title:"iOS SDK"},sidebar:"docs",previous:{title:"Android SDK",permalink:"/handbook/docs/dev-guide/dev-guide-android-sdk"},next:{title:"React Native SDK",permalink:"/handbook/docs/dev-guide/dev-guide-react-native-sdk"}},d={},c=[{value:"Sample applications using the SDK",id:"sample-applications-using-the-sdk",level:2},{value:"Usage",id:"usage",level:2},{value:"Using CocoaPods",id:"using-cocoapods",level:3},{value:"Building it yourself",id:"building-it-yourself",level:3},{value:"API",id:"api",level:2},{value:"JitsiMeetView class",id:"jitsimeetview-class",level:3},{value:"delegate",id:"delegate",level:4},{value:"join:JitsiMeetConferenceOptions",id:"joinjitsimeetconferenceoptions",level:4},{value:"leave",id:"leave",level:4},{value:"hangUp",id:"hangup",level:4},{value:"setAudioMuted",id:"setaudiomuted",level:4},{value:"setVideoMuted",id:"setvideomuted",level:4},{value:"sendEndpointTextMessage",id:"sendendpointtextmessage",level:4},{value:"toggleScreenShare",id:"togglescreenshare",level:4},{value:"openChat",id:"openchat",level:4},{value:"sendChatMessage",id:"sendchatmessage",level:4},{value:"closeChat",id:"closechat",level:4},{value:"retrieveParticipantsInfo",id:"retrieveparticipantsinfo",level:4},{value:"Universal / deep linking",id:"universal--deep-linking",level:4},{value:"JitsiMeetViewDelegate",id:"jitsimeetviewdelegate",level:3},{value:"conferenceJoined",id:"conferencejoined",level:4},{value:"conferenceTerminated",id:"conferenceterminated",level:4},{value:"conferenceWillJoin",id:"conferencewilljoin",level:4},{value:"enterPictureInPicture",id:"enterpictureinpicture",level:4},{value:"participantJoined",id:"participantjoined",level:4},{value:"participantLeft",id:"participantleft",level:4},{value:"audioMutedChanged",id:"audiomutedchanged",level:4},{value:"videoMutedChanged",id:"videomutedchanged",level:4},{value:"endpointTextMessageReceived",id:"endpointtextmessagereceived",level:4},{value:"screenShareToggled",id:"screensharetoggled",level:4},{value:"chatMessageReceived",id:"chatmessagereceived",level:4},{value:"chatToggled",id:"chattoggled",level:4},{value:"readyToClose",id:"readytoclose",level:4},{value:"Picture-in-Picture",id:"picture-in-picture",level:3},{value:"Dropbox integration",id:"dropbox-integration",level:2},{value:"Screen Sharing integration",id:"screen-sharing-integration",level:2},{value:"Creating the Broadcast Upload Extension",id:"creating-the-broadcast-upload-extension",level:3},{value:"Setting up the socket connection",id:"setting-up-the-socket-connection",level:3},{value:"Opening the socket connection",id:"opening-the-socket-connection",level:3},{value:"Sending video frames",id:"sending-video-frames",level:3},{value:"Handling stop screen sharing",id:"handling-stop-screen-sharing",level:3},{value:"TL;DR",id:"tldr",level:3}],u={toc:c};function h(e){var t=e.components,l=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The Jitsi Meet iOS SDK provides the same user experience as the Jitsi Meet app,\nin a customizable way which you can embed in your apps."),(0,o.kt)("admonition",{type:"important"},(0,o.kt)("p",{parentName:"admonition"},"iOS 12.4 or higher is required.")),(0,o.kt)("h2",{id:"sample-applications-using-the-sdk"},"Sample applications using the SDK"),(0,o.kt)("p",null,"If you want to see how easy integrating the Jitsi Meet SDK into a native application is, take a look at the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jitsi/jitsi-meet-sdk-samples#ios"},"sample applications repository"),"."),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"There are 2 ways to integrate the SDK into your project:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using CocoaPods"),(0,o.kt)("li",{parentName:"ul"},"Building it yourself")),(0,o.kt)("h3",{id:"using-cocoapods"},"Using CocoaPods"),(0,o.kt)("p",null,"The recommended way for using the SDK is by using CocoaPods. In order to\ndo so, add the ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetSDK")," dependency to your existing ",(0,o.kt)("inlineCode",{parentName:"p"},"Podfile")," or create\na new one following this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"platform :ios, '12.4'\n\nworkspace 'JitsiMeetSDKTest.xcworkspace'\n\ntarget 'JitsiMeetSDKTest' do\n  project 'JitsiMeetSDKTest.xcodeproj'\n\n  pod 'JitsiMeetSDK'\nend\n")),(0,o.kt)("p",null,"Replace ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetSDKTest")," with your project and target names."),(0,o.kt)("p",null,"Bitcode is not provided in the prebuilt SDK, so turn it off for your project."),(0,o.kt)("p",null,"The SDK uses Swift code, so make sure you select ",(0,o.kt)("inlineCode",{parentName:"p"},"Always Embed Swift Standard Libraries"),"\nin your project."),(0,o.kt)("p",null,"Since the SDK requests camera and microphone access, make sure to include the\nrequired entries for ",(0,o.kt)("inlineCode",{parentName:"p"},"NSCameraUsageDescription")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"NSMicrophoneUsageDescription"),"\nin your ",(0,o.kt)("inlineCode",{parentName:"p"},"Info.plist")," file."),(0,o.kt)("p",null,'In order for app to properly work in the background, select the "audio" and "voip"\nbackground modes.'),(0,o.kt)("p",null,"Last, since the SDK shows and hides the status bar based on the conference state,\nyou may want to set ",(0,o.kt)("inlineCode",{parentName:"p"},"UIViewControllerBasedStatusBarAppearance")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"NO")," in your\n",(0,o.kt)("inlineCode",{parentName:"p"},"Info.plist")," file."),(0,o.kt)("h3",{id:"building-it-yourself"},"Building it yourself"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Install all required ",(0,o.kt)("a",{parentName:"p",href:"https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-mobile-jitsi-meet"},"dependencies"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Build it:"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir -p ios/sdk/out\nxcodebuild clean \\\n    -workspace ios/jitsi-meet.xcworkspace \\\n    -scheme JitsiMeetSDK\nxcodebuild archive \\\n    -workspace ios/jitsi-meet.xcworkspace \\\n    -scheme JitsiMeetSDK  \\\n    -configuration Release \\\n    -sdk iphonesimulator \\\n    -destination='generic/platform=iOS Simulator' \\\n    -archivePath ios/sdk/out/ios-simulator \\\n    SKIP_INSTALL=NO \\\n    BUILD_LIBRARY_FOR_DISTRIBUTION=YES\nxcodebuild archive \\\n    -workspace ios/jitsi-meet.xcworkspace \\\n    -scheme JitsiMeetSDK  \\\n    -configuration Release \\\n    -sdk iphoneos \\\n    -destination='generic/platform=iOS' \\\n    -archivePath ios/sdk/out/ios-device \\\n    SKIP_INSTALL=NO \\\n    BUILD_LIBRARY_FOR_DISTRIBUTION=YES\nxcodebuild -create-xcframework \\\n    -framework ios/sdk/out/ios-device.xcarchive/Products/Library/Frameworks/JitsiMeetSDK.framework \\\n    -framework ios/sdk/out/ios-simulator.xcarchive/Products/Library/Frameworks/JitsiMeetSDK.framework \\\n    -output ios/sdk/out/JitsiMeetSDK.xcframework\n")),(0,o.kt)("p",null,"After successfully building Jitsi Meet SDK for iOS, the resulting XCFramework will be in the ios/sdk/out directory."),(0,o.kt)("p",null,"NOTE: Your app will need to depend on the JitsiWebRTC CocoaPod."),(0,o.kt)("h2",{id:"api"},"API"),(0,o.kt)("p",null,"JitsiMeet is an iOS framework which embodies the whole Jitsi Meet experience and\nmakes it reusable by third-party apps."),(0,o.kt)("p",null,"To get started:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add a ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView")," to your app using a Storyboard or Interface Builder,\nfor example.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Then, once the view has loaded, set the delegate in your controller and load\nthe desired URL:"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  JitsiMeetView *jitsiMeetView = (JitsiMeetView *) self.view;\n  jitsiMeetView.delegate = self;\n\n  JitsiMeetConferenceOptions *options = [JitsiMeetConferenceOptions fromBuilder:^(JitsiMeetConferenceOptionsBuilder *builder) {\n      builder.serverURL = [NSURL URLWithString:@"https://meet.jit.si"];\n      builder.room = @"test123";\n      builder.audioOnly = YES;\n  }];\n\n  [jitsiMeetView join:options];\n}\n')),(0,o.kt)("h3",{id:"jitsimeetview-class"},"JitsiMeetView class"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView")," class is the entry point to the SDK. It a subclass of\n",(0,o.kt)("inlineCode",{parentName:"p"},"UIView")," which renders a full conference in the designated area."),(0,o.kt)("h4",{id:"delegate"},"delegate"),(0,o.kt)("p",null,"Property to get/set the ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetViewDelegate")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView"),"."),(0,o.kt)("h4",{id:"joinjitsimeetconferenceoptions"},"join:JitsiMeetConferenceOptions"),(0,o.kt)("p",null,"Joins the conference specified by the given options."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'  JitsiMeetConferenceOptions *options = [JitsiMeetConferenceOptions fromBuilder:^(JitsiMeetConferenceOptionsBuilder *builder) {\n      builder.serverURL = [NSURL URLWithString:@"https://meet.jit.si"];\n      builder.room = @"test123";\n      builder.audioOnly = NO;\n      builder.audioMuted = NO;\n      builder.videoMuted = NO;\n      builder.welcomePageEnabled = NO;\n      [builder setConfigOverride:@"requireDisplayName" withBoolean:YES];\n  }];\n\n  [jitsiMeetView join:options];\n')),(0,o.kt)("h4",{id:"leave"},"leave"),(0,o.kt)("p",null,"Leaves the currently active conference."),(0,o.kt)("h4",{id:"hangup"},"hangUp"),(0,o.kt)("p",null,"The localParticipant leaves the current conference."),(0,o.kt)("h4",{id:"setaudiomuted"},"setAudioMuted"),(0,o.kt)("p",null,"Sets the state of the localParticipant audio muted according to the ",(0,o.kt)("inlineCode",{parentName:"p"},"muted")," parameter."),(0,o.kt)("h4",{id:"setvideomuted"},"setVideoMuted"),(0,o.kt)("p",null,"Sets the state of the localParticipant video muted according to the ",(0,o.kt)("inlineCode",{parentName:"p"},"muted")," parameter."),(0,o.kt)("h4",{id:"sendendpointtextmessage"},"sendEndpointTextMessage"),(0,o.kt)("p",null,"Sends a message via the data channel to one particular participant or to all of them.\nIf the ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," param is empty, the message will be sent to all the participants in the conference."),(0,o.kt)("p",null,"In order to get the participantId, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PARTICIPANT_JOINED")," event should be listened for,\nwhich ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," includes the id and this should be stored somehow."),(0,o.kt)("h4",{id:"togglescreenshare"},"toggleScreenShare"),(0,o.kt)("p",null,"Sets the state of the localParticipant screen sharing according to the ",(0,o.kt)("inlineCode",{parentName:"p"},"enabled")," parameter."),(0,o.kt)("h4",{id:"openchat"},"openChat"),(0,o.kt)("p",null,"Opens the chat dialog. If ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," contains a valid participantId, the private chat with that particular participant will be opened."),(0,o.kt)("h4",{id:"sendchatmessage"},"sendChatMessage"),(0,o.kt)("p",null,"Sends a chat message via to one particular participant or to all of them.\nIf the ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," param is empty, the message will be sent to all the participants in the conference."),(0,o.kt)("p",null,"In order to get the participantId, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PARTICIPANT_JOINED")," event should be listened for,\nwhich ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," includes the id and this should be stored somehow."),(0,o.kt)("h4",{id:"closechat"},"closeChat"),(0,o.kt)("p",null,"Closes the chat dialog."),(0,o.kt)("h4",{id:"retrieveparticipantsinfo"},"retrieveParticipantsInfo"),(0,o.kt)("p",null,"Retrieves the participants information in the completionHandler sent as parameter."),(0,o.kt)("h4",{id:"universal--deep-linking"},"Universal / deep linking"),(0,o.kt)("p",null,"In order to support Universal / deep linking, ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeet")," offers 2 class\nmethods that you app's delegate should call in order for the app to follow those\nlinks."),(0,o.kt)("p",null,"If these functions return NO it means the URL wasn't handled by the SDK. This\nis useful when the host application uses other SDKs which also use linking."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"-  (BOOL)application:(UIApplication *)application\ncontinueUserActivity:(NSUserActivity *)userActivity\n  restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler\n{\n  return [[JitsiMeet sharedInstance] application:application\n               continueUserActivity:userActivity\n                 restorationHandler:restorationHandler];\n}\n")),(0,o.kt)("p",null,"And also one of the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"// See https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application?language=objc\n- (BOOL)application:(UIApplication *)app\n            openURL:(NSURL *)url\n            options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {\n  return [[JitsiMeet sharedInstance] application:app\n                            openURL:url\n                            options: options];\n}\n")),(0,o.kt)("h3",{id:"jitsimeetviewdelegate"},"JitsiMeetViewDelegate"),(0,o.kt)("p",null,"This delegate is optional, and can be set on the ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView")," instance using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"delegate")," property."),(0,o.kt)("p",null,"It provides information about the conference state: was it joined, left, did it\nfail?"),(0,o.kt)("p",null,"All methods in this delegate are optional."),(0,o.kt)("h4",{id:"conferencejoined"},"conferenceJoined"),(0,o.kt)("p",null,"Called when a conference was joined. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"url"),": the conference URL")),(0,o.kt)("h4",{id:"conferenceterminated"},"conferenceTerminated"),(0,o.kt)("p",null,"Called when the active conference ends, be it because of user choice or because of a failure. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the\nfollowing information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"url"),": the conference URL"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"error"),": missing if the conference finished gracefully, otherwise contains the error message")),(0,o.kt)("h4",{id:"conferencewilljoin"},"conferenceWillJoin"),(0,o.kt)("p",null,"Called before a conference is joined. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"url"),": the conference URL")),(0,o.kt)("h4",{id:"enterpictureinpicture"},"enterPictureInPicture"),(0,o.kt)("p",null,"Called when entering Picture-in-Picture is requested by the user. The app should\nnow activate its Picture-in-Picture implementation (and resize the associated\n",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView"),". The latter will automatically detect its new size and adjust\nits user interface to a variant appropriate for the small size ordinarily\nassociated with Picture-in-Picture.)"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," dictionary is empty."),(0,o.kt)("h4",{id:"participantjoined"},"participantJoined"),(0,o.kt)("p",null,"Called when a participant has joined the conference. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"email"),": the email of the participant. It may not be set if the remote participant didn't set one."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name"),": the name of the participant."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"role"),": the role of the participant."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"participantId"),": the id of the participant.")),(0,o.kt)("h4",{id:"participantleft"},"participantLeft"),(0,o.kt)("p",null,"Called when a participant has left the conference. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"participantId"),": the id of the participant that left.")),(0,o.kt)("h4",{id:"audiomutedchanged"},"audioMutedChanged"),(0,o.kt)("p",null,"Called when the local participant's audio is muted or unmuted. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"muted"),": a boolean indicating whether the audio is muted or not.")),(0,o.kt)("h4",{id:"videomutedchanged"},"videoMutedChanged"),(0,o.kt)("p",null,"Called when the local participant's video is muted or unmuted. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"muted"),": an integer indicating whether the video is muted or not. 0 means unmuted, 4 means muted.")),(0,o.kt)("h4",{id:"endpointtextmessagereceived"},"endpointTextMessageReceived"),(0,o.kt)("p",null,"Called when an endpoint text message is received."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," dictionary contains a ",(0,o.kt)("inlineCode",{parentName:"p"},"senderId")," key with the participantId of the sender and a ",(0,o.kt)("inlineCode",{parentName:"p"},"message")," key with the\ncontent."),(0,o.kt)("h4",{id:"screensharetoggled"},"screenShareToggled"),(0,o.kt)("p",null,"Called when a participant starts or stops sharing his screen."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," dictionary contains a ",(0,o.kt)("inlineCode",{parentName:"p"},"participantId")," key with the id of the participant and a 'sharing' key with boolean\nvalue."),(0,o.kt)("h4",{id:"chatmessagereceived"},"chatMessageReceived"),(0,o.kt)("p",null,"Called when a chat text message is received. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"senderId"),": the id of the participant that sent the message."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"message"),": the content of the message."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isPrivate"),": true if the message is private, false otherwise."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"timestamp"),": the (optional) timestamp of the message.")),(0,o.kt)("h4",{id:"chattoggled"},"chatToggled"),(0,o.kt)("p",null,"Called when the chat dialog is opened or closed. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," contains the following information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isOpen"),": true if the chat dialog is open, false otherwise.")),(0,o.kt)("h4",{id:"readytoclose"},"readyToClose"),(0,o.kt)("p",null,"Called when the SDK is ready to be closed. No meeting is happening at this point."),(0,o.kt)("h3",{id:"picture-in-picture"},"Picture-in-Picture"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView"),' will automatically adjust its UI when presented in a\nPicture-in-Picture style scenario, in a rectangle too small to accommodate its\n"full" UI.'),(0,o.kt)("p",null,"Jitsi Meet SDK does not currently implement native Picture-in-Picture on iOS. If\ndesired, apps need to implement non-native Picture-in-Picture themselves and\nresize ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetView"),"."),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"delegate")," implements ",(0,o.kt)("inlineCode",{parentName:"p"},"enterPictureInPicture:"),", the in-call toolbar will\nrender a button to afford the user to request entering Picture-in-Picture."),(0,o.kt)("h2",{id:"dropbox-integration"},"Dropbox integration"),(0,o.kt)("p",null,"To setup the Dropbox integration, follow these steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Add the following to the app's Info.plist and change ",(0,o.kt)("inlineCode",{parentName:"li"},"<APP_KEY>")," to your\nDropbox app key:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<key>CFBundleURLTypes</key>\n<array>\n  <dict>\n    <key>CFBundleURLName</key>\n    <string></string>\n    <key>CFBundleURLSchemes</key>\n    <array>\n      <string>db-<APP_KEY></string>\n    </array>\n  </dict>\n</array>\n<key>LSApplicationQueriesSchemes</key>\n<array>\n  <string>dbapi-2</string>\n  <string>dbapi-8-emm</string>\n</array>\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Make sure your app calls the Jitsi Meet SDK universal / deep linking delegate methods.")),(0,o.kt)("h2",{id:"screen-sharing-integration"},"Screen Sharing integration"),(0,o.kt)("p",null,"The screen sharing functionality for iOS was added to Jitsi starting with JitsiMeetSDK version 3.3.0. It is available for applications running on iOS 14 or newer."),(0,o.kt)("p",null,"For achieving this we are using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Broadcast Upload Extension")," for capturing the contents of the user's screen. Passing the frames to the RN WebRTC is done using Unix stream-oriented sockets communication, the extension acting as the client and the React Native WebRTC being the server."),(0,o.kt)("p",null,"The following documentation covers the code provided in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jitsi/jitsi-meet-sdk-samples/tree/master/ios/swift-screensharing/JitsiSDKScreenSharingTest"},"sample app"),"."),(0,o.kt)("h3",{id:"creating-the-broadcast-upload-extension"},"Creating the Broadcast Upload Extension"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Broadcast Upload Extension")," is one of the App Extensions types defined in iOS and is used for capturing the contents of the user's screen."),(0,o.kt)("p",null,"For creating the extension you need to add a new target to your application, selecting the ",(0,o.kt)("inlineCode",{parentName:"p"},"Broadcast Upload Extension")," template. Fill in the desired name, change the language to Swift, make sure ",(0,o.kt)("inlineCode",{parentName:"p"},"Include UI Extension")," is not selected, as we don't need custom UI for our case, then press Finish (screenshot 1). You will see that a new folder with the extension's name was added to the project's tree, containing the ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler.swift")," class. Also, make sure to update the ",(0,o.kt)("inlineCode",{parentName:"p"},"Deployment Info"),", for the newly created extension, to iOS 14 or newer. To learn more about creating App Extensions check the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionCreation.html"},"official documentation"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"screenshot 1",src:n(1798).Z,title:"screenshot 1",width:"594",height:"402"})),(0,o.kt)("p",null,"With the extension created the next steps are to set up the socket connection, add the functionality for handling the received frames, and send them to RN WebRTC for processing. We will be using the code provided with the sample project for this. Copy ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleUploader.swift"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"SocketConnection.swift"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"DarwinNotificationCenter.swift"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Atomic.swift")," files to your extension's folder and make sure they're added to the target."),(0,o.kt)("h3",{id:"setting-up-the-socket-connection"},"Setting up the socket connection"),(0,o.kt)("p",null,"Sending the recorded frames to RN WebRTC is done via Unix SOCK_STREAM sockets. The extension needs to be set up as the client endpoint for this."),(0,o.kt)("p",null,"We will update ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler.swift")," to initiate the socket connection with RN WebRTC, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"SocketConnection")," class. But before, we have to set up the file that the sockets will use for communication."),(0,o.kt)("p",null,"Even though an app extension bundle is nested within its containing app\u2019s bundle, the running app extension and containing app have no direct access to each other\u2019s containers. We will address this by enabling data sharing. To enable data sharing, use Xcode or the Developer portal to enable app groups for the containing app and its contained app extensions. Next, register the app group in the portal and specify the app group to use in the containing app. To learn about working with app groups, see ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19"},"Adding an App to an App Group"),"."),(0,o.kt)("p",null,"Now, add a ",(0,o.kt)("inlineCode",{parentName:"p"},"private var socketFilePath: String")," to your ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler")," class and set it up with a shared file named ",(0,o.kt)("inlineCode",{parentName:"p"},"rtc_SSFD"),", using the newly registered app group, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'private enum Constants {\n    static let appGroupIdentifier = "my.custom.app.group"\n}\n\nprivate var socketFilePath: String {\n    let sharedContainer = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: Constants.appGroupIdentifier)\n     \n    return sharedContainer?.appendingPathComponent("rtc_SSFD").path ?? ""\n}\n')),(0,o.kt)("p",null,"Next, we will configure the ",(0,o.kt)("inlineCode",{parentName:"p"},"SocketConnection")," to use the shared file. Add a ",(0,o.kt)("inlineCode",{parentName:"p"},"private var clientConnection: SocketConnection?")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler")," class and override ",(0,o.kt)("inlineCode",{parentName:"p"},"init")," to set it up, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"override init() {\n    super.init()\n    if let connection = SocketConnection(filePath: socketFilePath) {\n        clientConnection = connection\n    }\n} \n")),(0,o.kt)("p",null,"In order for this to work, the RN WebRTC end needs to know about the app group identifier we have configured the app with. We are doing this by adding a new key named ",(0,o.kt)("inlineCode",{parentName:"p"},"RTCAppGroupIdentifier")," to the app's ",(0,o.kt)("inlineCode",{parentName:"p"},"Info.plist")," with the app group identifier as the value."),(0,o.kt)("h3",{id:"opening-the-socket-connection"},"Opening the socket connection"),(0,o.kt)("p",null,"For starting screen sharing JitsiMeet SDK provides the UI to present the ",(0,o.kt)("inlineCode",{parentName:"p"},"RPSystemBroadcastPickerView")," to the user. By default, the picker will display a list of all the available broadcast providers. In order to limit the picker to our particular broadcast provider, we have to set ",(0,o.kt)("inlineCode",{parentName:"p"},"preferredExtension")," to the bundle identifier of the broadcast extension. We are doing this by adding a new key named ",(0,o.kt)("inlineCode",{parentName:"p"},"RTCScreenSharingExtension")," to the app's Info.plist and setting the broadcast extension bundle identifier as the value."),(0,o.kt)("p",null,"Once screen recording has started ReplayKit invokes the methods to handle video buffers, as well as the methods to handle starting and stopping the broadcast, from the ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler")," class. The ",(0,o.kt)("inlineCode",{parentName:"p"},"broadcastStarted(withSetupInfo:)")," method is our entry point for opening the socket connection with the RN WebRTC server. To do this we have to post the ",(0,o.kt)("inlineCode",{parentName:"p"},"broadcastStarted")," notification the server is listening for, in order to start the connection, and we are ready to connect. Add a new method ",(0,o.kt)("inlineCode",{parentName:"p"},"openConnection()")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler")," class which will repeatedly attempt connecting to the server, for cases when the server connection start is delayed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'func openConnection() {\n    let queue = DispatchQueue(label: "broadcast.connectTimer")\n    let timer = DispatchSource.makeTimerSource(queue: queue)\n    timer.schedule(deadline: .now(), repeating: .milliseconds(100), leeway: .milliseconds(500))\n    timer.setEventHandler { [weak self] in\n        guard self?.clientConnection?.open() == true else {\n            return\n        }\n        \n        timer.cancel()\n    }\n    \n    timer.resume()\n}\n')),(0,o.kt)("p",null,"Next, update the ",(0,o.kt)("inlineCode",{parentName:"p"},"broadcastStarted(withSetupInfo:)")," method to post the notification and connect:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"override func broadcastStarted(withSetupInfo setupInfo: [String: NSObject]?) {\n    DarwinNotificationCenter.shared.postNotification(.broadcastStarted)\n    openConnection()\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DarwinNotificationCenter")," is a simple helper class for broadcasting system-wide notifications, instead of delivering only within a single program, as ",(0,o.kt)("inlineCode",{parentName:"p"},"NSNotificationCenter")," does. This mechanism allows the app to register for notifications sent from the extension."),(0,o.kt)("p",null,"Now we are ready to start sending video frames."),(0,o.kt)("h3",{id:"sending-video-frames"},"Sending video frames"),(0,o.kt)("p",null,"RN WebRTC is designed to work with jpeg encoded images framed in a ",(0,o.kt)("inlineCode",{parentName:"p"},"CFHTTPMessage")," object. The following header fields are required:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Content-Length")," - the size of the jpeg data"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Buffer-Width")," - the width of the buffer, in pixels"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Buffer-Height")," - the buffer height, in pixels"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Buffer-Orientation")," - the value for the ",(0,o.kt)("inlineCode",{parentName:"li"},"RPVideoSampleOrientationKey")," that describes the video orientation.")),(0,o.kt)("p",null,"We are going to prepare and send our video frames using the ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleUploader")," class. Add a new ",(0,o.kt)("inlineCode",{parentName:"p"},"private var uploader: SampleUploader?")," to the SampleHandler class and update ",(0,o.kt)("inlineCode",{parentName:"p"},"init()")," to initialize it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"override init() {\n    super.init()\n    if let connection = SocketConnection(filePath: socketFilePath) {\n      clientConnection = connection\n      uploader = SampleUploader(connection: connection)\n    }\n}\n")),(0,o.kt)("p",null,"Next, we are going to update the ",(0,o.kt)("inlineCode",{parentName:"p"},"processSampleBuffer(_ sampleBuffer: CMSampleBuffer, with sampleBufferType: RPSampleBufferType)")," method to send our video frames. For performance reasons, we'll also implement a very simple mechanism for adjusting the frame rate by using every third frame. Add a new ",(0,o.kt)("inlineCode",{parentName:"p"},"private var frameCount = 0")," and update the above-mentioned method like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"override func processSampleBuffer(_ sampleBuffer: CMSampleBuffer, with sampleBufferType: RPSampleBufferType) {\n    switch sampleBufferType {\n    case .video:\n        // very simple mechanism for adjusting frame rate by using every third frame\n        frameCount += 1\n        if frameCount % 3 == 0 {\n            uploader?.send(sample: sampleBuffer)\n        }\n    default:\n        break\n    }\n}\n")),(0,o.kt)("p",null,"Also, update ",(0,o.kt)("inlineCode",{parentName:"p"},"broadcastStarted(withSetupInfo setupInfo: [String: NSObject]?)")," to reset the ",(0,o.kt)("inlineCode",{parentName:"p"},"frameCount")," every time screen sharing is started:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"override func broadcastStarted(withSetupInfo setupInfo: [String: NSObject]?) {\n    frameCount = 0\n    \n    DarwinNotificationCenter.shared.postNotification(.broadcastStarted)\n    openConnection()\n}\n")),(0,o.kt)("p",null,"With this, we've concluded sending the video frames and we can move to the last step, handling stop screen sharing."),(0,o.kt)("h3",{id:"handling-stop-screen-sharing"},"Handling stop screen sharing"),(0,o.kt)("p",null,"Besides the in-meeting UI (screenshot 2), ReplayKit integration with iOS provides support for stopping screen recording outside of the app's control, from the status bar (screenshot 3) or using the Control Center (screenshot 4)."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"ios-screensharing",src:n(1082).Z,title:"screenshot 2",width:"226",height:"487"})," ",(0,o.kt)("img",{alt:"ios-screensharing",src:n(6195).Z,title:"screenshot 3",width:"226",height:"487"})," ",(0,o.kt)("img",{alt:"ios-screensharing",src:n(9166).Z,title:"screenshot 4",width:"226",height:"487"})," "),(0,o.kt)("p",null,"Any of these actions will trigger ",(0,o.kt)("inlineCode",{parentName:"p"},"broadcastFinished")," in our ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler")," implementation. This is our entry point for closing the connection and cleaning up. We will update ",(0,o.kt)("inlineCode",{parentName:"p"},"broadcastFinished")," to post a ",(0,o.kt)("inlineCode",{parentName:"p"},"DarwinNotification.broadcastStopped")," system-wide notification and close the connection:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"override func broadcastFinished() {\n    DarwinNotificationCenter.shared.postNotification(.broadcastStopped)\n    clientConnection?.close()\n}\n")),(0,o.kt)("p",null,"Another scenario we need to take care of is when the server connection is dropped, like when leaving a meeting while screen sharing or an error is encountered. We will address this by handling ",(0,o.kt)("inlineCode",{parentName:"p"},"clientConnection.didClose")," event. Add a new method ",(0,o.kt)("inlineCode",{parentName:"p"},"setupConnection")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"SampleHandler")," class and update ",(0,o.kt)("inlineCode",{parentName:"p"},"init")," to call it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'func setupConnection() {\n    clientConnection?.didClose = { [weak self] error in      \n        if let error = error {\n            self?.finishBroadcastWithError(error)\n        } else {\n            // the displayed failure message is more user friendly when using NSError instead of Error\n            let JMScreenSharingStopped = 10001\n            let customError = NSError(domain: RPRecordingErrorDomain, code: JMScreenSharingStopped, userInfo: [NSLocalizedDescriptionKey: "Screen sharing stopped"])\n            self?.finishBroadcastWithError(customError)\n        }\n    }\n}\n\noverride init() {\n    super.init()\n    if let connection = SocketConnection(filePath: socketFilePath) {\n      clientConnection = connection\n      setupConnection()\n      \n      uploader = SampleUploader(connection: connection)\n    }\n}\n')),(0,o.kt)("p",null,"Now, that we are done writing the implementation, we just need to enable the functionality in Jitsi. We are doing this by configuring ",(0,o.kt)("inlineCode",{parentName:"p"},"JitsiMeetConferenceOptionsBuilder")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ios.screensharing.enabled feature")," flag, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'let options = JitsiMeetConferenceOptions.fromBuilder { [weak self] builder in\n    ...\n    builder.setFeatureFlag("ios.screensharing.enabled", withBoolean: true)\n}\nmeetView.join(options)\n')),(0,o.kt)("p",null,"Finally, we are ready to test the implementation. Before doing so, make sure voip is added to ",(0,o.kt)("inlineCode",{parentName:"p"},"UIBackgroundModes"),", in the app's ",(0,o.kt)("inlineCode",{parentName:"p"},"Info.playlist"),", in order to work when the app is in the background."),(0,o.kt)("h3",{id:"tldr"},"TL;DR"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Add a ",(0,o.kt)("inlineCode",{parentName:"li"},"Broadcast Upload Extension"),", without UI, to your app. Update deployment info to run in iOS 14 or newer."),(0,o.kt)("li",{parentName:"ul"},"Copy ",(0,o.kt)("inlineCode",{parentName:"li"},"SampleUploader.swift"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"SocketConnection.swift"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"DarwinNotificationCenter.swift")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Atomic.swift")," files from the sample project to your extension. Make sure they are added to the extension's target."),(0,o.kt)("li",{parentName:"ul"},"Add both the app and the extension to the same App Group. Next, add the app group id value to the app's ",(0,o.kt)("inlineCode",{parentName:"li"},"Info.plist")," for the ",(0,o.kt)("inlineCode",{parentName:"li"},"RTCAppGroupIdentifier")," key."),(0,o.kt)("li",{parentName:"ul"},"Add a new key ",(0,o.kt)("inlineCode",{parentName:"li"},"RTCScreenSharingExtension")," to the app's ",(0,o.kt)("inlineCode",{parentName:"li"},"Info.plist")," with the extension's ",(0,o.kt)("inlineCode",{parentName:"li"},"Bundle Identifier")," as the value."),(0,o.kt)("li",{parentName:"ul"},"Update ",(0,o.kt)("inlineCode",{parentName:"li"},"SampleHandler.swift")," with the code from the sample project. Update ",(0,o.kt)("inlineCode",{parentName:"li"},"appGroupIdentifier")," constant with the App Group name your app and extension are both registered to."),(0,o.kt)("li",{parentName:"ul"},"Update ",(0,o.kt)("inlineCode",{parentName:"li"},"JitsiMeetConferenceOptions")," to enable screen sharing using the ",(0,o.kt)("inlineCode",{parentName:"li"},"ios.screensharing.enabled")," feature flag."),(0,o.kt)("li",{parentName:"ul"},"Make sure ",(0,o.kt)("inlineCode",{parentName:"li"},"voip")," is added to ",(0,o.kt)("inlineCode",{parentName:"li"},"UIBackgroundModes"),", in the app's ",(0,o.kt)("inlineCode",{parentName:"li"},"Info.plist"),", in order to work when the app is in the background.")))}h.isMDXComponent=!0},1798:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/iOS_screensharing_1-9fc051cab7c6c45813ac86a09d9be7f8.png"},1082:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/iOS_screensharing_2-e4305e7a7935b01689f316310cae41e9.png"},6195:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/iOS_screensharing_3-83343a2407deba42d29b363470fa4680.png"},9166:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/iOS_screensharing_4-985c0a05d859624dab3201410a425ca1.png"}}]);